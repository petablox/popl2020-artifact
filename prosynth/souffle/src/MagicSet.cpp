/*
 * Souffle - A Datalog Compiler
 * Copyright (c) 2017, The Souffle Developers. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at:
 * - https://opensource.org/licenses/UPL
 * - <souffle root>/licenses/SOUFFLE-UPL.txt
 */

/************************************************************************
 *
 * @file MagicSet.cpp
 *
 * Define classes and functionality related to the magic set transformation.
 *
 ***********************************************************************/

#include "MagicSet.h"
#include "AstAttribute.h"
#include "AstIO.h"
#include "AstIOTypeAnalysis.h"
#include "AstNode.h"
#include "AstProgram.h"
#include "AstRelation.h"
#include "AstTransforms.h"
#include "AstTranslationUnit.h"
#include "BinaryConstraintOps.h"
#include "Global.h"
#include "IODirectives.h"
#include "RelationRepresentation.h"
#include "SrcLocation.h"
#include "Util.h"
#include <cassert>
#include <utility>

namespace souffle {

class SymbolTable;

/* general functions */

// checks whether the adorned version of two predicates is equal
bool isEqualAdornment(const AstRelationIdentifier& pred1, const std::string& adorn1,
        const AstRelationIdentifier& pred2, const std::string& adorn2) {
    return ((pred1 == pred2) && (adorn1.compare(adorn2) == 0));
}

// checks whether an element is contained within a set
template <class T>
bool contains(std::set<T> set, T element) {
    return (set.find(element) != set.end());
}

// checks whether a given adorned predicate is contained within a set
bool contains(std::set<AdornedPredicate> adornedPredicates, const AstRelationIdentifier& atomName,
        const std::string& atomAdornment) {
    for (AdornedPredicate seenPred : adornedPredicates) {
        if (isEqualAdornment(seenPred.getName(), seenPred.getAdornment(), atomName, atomAdornment)) {
            return true;
        }
    }
    return false;
}

// checks whether a string begins with a given string
bool hasPrefix(const std::string& str, const std::string& prefix) {
    if (str.substr(0, prefix.size()).compare(prefix) == 0) {
        return true;
    }
    return false;
}

// checks whether the given relation is generated by an aggregator
bool isAggRel(const AstRelationIdentifier& rel) {
    // TODO (azreika): this covers too much (e.g. user-defined __agg_rel_x)
    //                 need a way to determine if created by aggregates
    return hasPrefix(rel.getNames()[0], "__agg_rel_");
}

// gets the position of the final underscore in a given string
int getEndpoint(std::string mainName) {
    int endpt = mainName.size() - 1;
    while (endpt >= 0 && mainName[endpt] != '_') {
        endpt--;
    }
    if (endpt == -1) {
        endpt = mainName.size();
    }
    return endpt;
}

/* argument-related functions */

// returns the string representation of a given argument
std::string getString(const AstArgument* arg) {
    std::stringstream argStream;
    argStream << *arg;
    return argStream.str();
}

// checks whether a given record or functor is bound
bool isBoundComposite(const AstVariable* compositeVariable, const std::set<std::string>& boundArgs,
        BindingStore& compositeBindings) {
    std::string variableName = compositeVariable->getName();
    if (contains(boundArgs, variableName)) {
        return true;
    }

    bool bound = true;

    // a composite argument is bound iff all its subvariables are bound
    auto dependencies = compositeBindings.getVariableDependencies(variableName);
    for (const std::string& var : dependencies) {
        if (!contains(boundArgs, var)) {
            bound = false;
        }
    }

    if (bound) {
        // composite variable bound only because its constituent variables are bound
        compositeBindings.addVariableBoundComposite(variableName);
    }

    return bound;
}

bool isBoundArgument(
        AstArgument* arg, const std::set<std::string>& boundArgs, BindingStore& compositeBindings) {
    if (auto* var = dynamic_cast<AstVariable*>(arg)) {
        std::string variableName = var->getName();
        if (hasPrefix(variableName, "+functor") || hasPrefix(variableName, "+record")) {
            if (isBoundComposite(var, boundArgs, compositeBindings)) {
                return true;
            }
        }

        if (contains(boundArgs, variableName)) {
            return true;  // found a bound argument, so can stop
        }
    } else {
        assert(false && "incomplete checks (MST)");
    }

    return false;
}

// checks whether a given atom has a bound argument
bool hasBoundArgument(
        AstAtom* atom, const std::set<std::string>& boundArgs, BindingStore& compositeBindings) {
    for (AstArgument* arg : atom->getArguments()) {
        if (isBoundArgument(arg, boundArgs, compositeBindings)) {
            return true;
        }
    }
    return false;
}

// checks whether the lhs is bound by a binary constraint (and is not bound yet)
bool isBindingConstraint(AstArgument* lhs, AstArgument* rhs, std::set<std::string> boundArgs) {
    std::string lhs_name = getString(lhs);
    std::string rhs_name = getString(rhs);

    // only want to check variables we have not bound yet
    if (dynamic_cast<AstVariable*>(lhs) && (boundArgs.find(lhs_name) == boundArgs.end())) {
        // return true if the rhs is a bound variable or a constant
        if (dynamic_cast<AstVariable*>(rhs) && (boundArgs.find(rhs_name) != boundArgs.end())) {
            return true;
        } else if (dynamic_cast<AstConstant*>(rhs)) {
            return true;
        }
    }
    return false;
}

// checks whether the clause involves aggregators
bool containsAggregators(AstClause* clause) {
    bool found = false;

    // check for aggregators
    visitDepthFirst(*clause, [&](const AstAggregator& aggr) { found = true; });

    return found;
}

/* program-adding related functions */

// returns the new source location of a newly-created node
SrcLocation nextSrcLoc(SrcLocation orig) {
    static int pos = 0;
    pos += 1;

    SrcLocation newLoc;
    newLoc.filename = orig.filename + " [MAGIC_FILE]";
    newLoc.start.line = pos;
    newLoc.end.line = pos;
    newLoc.start.column = 0;
    newLoc.end.column = 1;

    return newLoc;
}

// returns the next available relation name prefixed by "newedb"
std::string getNextEdbName(AstProgram* program) {
    static int edbNum = 0;
    std::stringstream newEdbName;

    // find the next unused relation name of the form "newedbX", X an integer
    do {
        newEdbName.str("");  // check
        edbNum++;
        newEdbName << "newedb" << edbNum;
    } while (program->getRelation(newEdbName.str()) != nullptr);

    return newEdbName.str();
}

// copies over necessary qualifiers from original into new relation
// note that input/output directives are handled at the end of the MST
void updateQualifier(AstRelation* originalRelation, AstRelation* newRelation) {
    int currentQualifier = newRelation->getQualifier();

    if (originalRelation->getRepresentation() == RelationRepresentation::EQREL) {
        currentQualifier |= EQREL_RELATION;
    }

    newRelation->setQualifier(currentQualifier);
}

// create a new relation with a given name based on a previous relation
AstRelation* createNewRelation(AstRelation* original, const AstRelationIdentifier& newName) {
    auto* newRelation = new AstRelation();
    newRelation->setSrcLoc(nextSrcLoc(original->getSrcLoc()));
    newRelation->setName(newName);

    // copy over the attributes from the original relation
    for (AstAttribute* attr : original->getAttributes()) {
        newRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
    }

    // copy over necessary qualifiers
    updateQualifier(original, newRelation);

    return newRelation;
}

// returns the magic-set identifier corresponding to a given relation (mX_relation)
AstRelationIdentifier createMagicIdentifier(const AstRelationIdentifier& relationName, size_t outputNumber) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name to magic-relation format
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << "+m" << outputNumber << "_" << relationNames[0];  // use "+m" to avoid conflicts
    AstRelationIdentifier newRelationName(newMainName.str());

    // copy over the other relation names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the adorned identifier corresponding to a given relation and adornment (relationName_adornment)
AstRelationIdentifier createAdornedIdentifier(
        const AstRelationIdentifier& relationName, const std::string& adornment) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name
    std::stringstream newMainName;
    newMainName.str("");
    // add a '+' to avoid name conflict
    newMainName << relationNames[0] << "+_" << adornment;
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the other names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the requested substring of a given identifier
AstRelationIdentifier createSubIdentifier(
        const AstRelationIdentifier& relationName, size_t start, size_t length) {
    std::vector<std::string> relationNames = relationName.getNames();

    // get the substring of the base name
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << relationNames[0].substr(start, length);
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the remaining names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

/* functions to find atoms to ignore */

// add all atoms within a clause that contain aggregators to the ignored relations list
std::set<AstRelationIdentifier> addAggregators(
        AstClause* clause, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = std::move(ignoredNames);

    visitDepthFirst(*clause, [&](const AstAggregator& aggregator) {
        visitDepthFirst(aggregator, [&](const AstAtom& atom) { retVal.insert(atom.getName()); });
    });

    return retVal;
}

// Given a set of relations R, add in all relations that use one of these
// relations in their clauses. Repeat until a fixed point is reached.
std::set<AstRelationIdentifier> addBackwardDependencies(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    bool relationsAdded = false;
    std::set<AstRelationIdentifier> result;

    for (AstRelationIdentifier relName : relations) {
        // Add the relation itself
        result.insert(relName);
    }

    // Add in all relations that need to use an ignored relation
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            AstRelationIdentifier clauseHeadName = clause->getHead()->getName();
            if (!contains(relations, clauseHeadName)) {
                // Clause hasn't been added yet, so check if it needs to be added
                visitDepthFirst(*clause, [&](const AstAtom& subatom) {
                    AstRelationIdentifier atomName = subatom.getName();
                    if (contains(relations, atomName)) {
                        // Clause uses one of the given relations
                        result.insert(clauseHeadName);

                        // Clause name hasn't been seen yet, so fixed point not reached
                        relationsAdded = true;
                    }
                });
            }
        }
    }

    if (relationsAdded) {
        // Keep going until we reach a fixed point
        return addBackwardDependencies(program, result);
    } else {
        return result;
    }
}

// Given a set of relations R, add in all relations that they use in their clauses.
// Repeat until a fixed point is reached.
std::set<AstRelationIdentifier> addForwardDependencies(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    bool relationsAdded = false;
    std::set<AstRelationIdentifier> result;

    for (AstRelationIdentifier relName : relations) {
        // Add the relation itself
        result.insert(relName);

        // Add in all the relations that it needs to use
        AstRelation* associatedRelation = program->getRelation(relName);
        for (AstClause* clause : associatedRelation->getClauses()) {
            visitDepthFirst(*clause, [&](const AstAtom& subatom) {
                AstRelationIdentifier atomName = subatom.getName();
                result.insert(atomName);
                if (!contains(relations, atomName)) {
                    // Hasn't been seen yet, so fixed point not reached
                    relationsAdded = true;
                }
            });
        }
    }

    if (relationsAdded) {
        // Keep going until we reach a fixed point
        return addForwardDependencies(program, result);
    } else {
        return result;
    }
}

// ensures that every relation not specified by the magic-transform option
// is ignored by the transformation
std::set<AstRelationIdentifier> addIgnoredRelations(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    // get a vector of all relations specified by the option
    std::vector<std::string> specifiedRelations = splitString(Global::config().get("magic-transform"), ',');

    // if a star was used as a relation, then magic set will be performed for all nodes
    if (contains(specifiedRelations, "*")) {
        return relations;
    }

    // find all specified relations
    std::set<AstRelationIdentifier> targetRelations;
    for (AstRelation* rel : program->getRelations()) {
        std::string mainName = rel->getName().getNames()[0];
        if (contains(specifiedRelations, mainName)) {
            targetRelations.insert(rel->getName());
        }
    }

    // add all backward-dependencies to the list of relations to transform;
    // if we want to magic transform 'a', then we also have to magic transform
    // every relation that (directly or indirectly) uses 'a' in its clauses
    targetRelations = addBackwardDependencies(program, targetRelations);

    // ignore all relations not specified by the option
    std::set<AstRelationIdentifier> retVal(relations);
    for (AstRelation* rel : program->getRelations()) {
        if (!contains(targetRelations, rel->getName())) {
            retVal.insert(rel->getName());
        }
    }

    return retVal;
}

/* =======================  *
 *        Adornment         *
 * =======================  */

// reorders a vector of integers to fit the clause atom-reordering function
std::vector<unsigned int> reorderOrdering(std::vector<unsigned int> order) {
    // when the adornment is computed, the atoms are numbered based on
    // which was chosen by the SIPS first - this is the 'order' vector.
    // want to reorder clause atoms so that the atom labelled 0 is first, and so on.
    // i.e. order[i] denotes where labels[i] should move
    // e.g.: [a, b, c] with label [1, 2, 0] should become [c, a, b]

    // the atom reordering function for clauses, however, moves it as follows:
    // [a, b, c] with label [1, 2, 0] becomes [b, c, a]
    // i.e. labels[i] goes to the position of i in the order vector

    // this function reorders the ordering scheme to match the second type
    std::vector<unsigned int> neworder(order.size());
    for (size_t i = 0; i < order.size(); i++) {
        // this took embarrassingly long to figure out
        neworder[order[i]] = i;
    }
    return neworder;
}

// reorders an adornment based on a given ordering scheme
std::vector<std::string> reorderAdornment(
        std::vector<std::string> adornment, std::vector<unsigned int> order) {
    // order[i] denotes where labels[i] should move
    // [a, b, c] with order [1, 2, 0] -> [c, a, b]
    std::vector<std::string> result(adornment.size());
    for (size_t i = 0; i < adornment.size(); i++) {
        result[order[i]] = adornment[i];
    }
    return result;
}

// computes the adornment of a newly chosen atom
// returns both the adornment and the new list of bound arguments
std::pair<std::string, std::set<std::string>> bindArguments(
        AstAtom* currAtom, std::set<std::string> boundArgs, BindingStore& compositeBindings) {
    std::set<std::string> newlyBoundArgs;
    std::string atomAdornment = "";

    for (AstArgument* arg : currAtom->getArguments()) {
        if (isBoundArgument(arg, boundArgs, compositeBindings)) {
            atomAdornment += "b";  // bound
        } else {
            atomAdornment += "f";  // free
            std::string argName = getString(arg);
            newlyBoundArgs.insert(argName);  // now bound
        }
    }

    // add newly bound arguments to the list of bound arguments
    for (std::string newArg : newlyBoundArgs) {
        boundArgs.insert(newArg);
    }

    return std::make_pair(atomAdornment, boundArgs);
}

// SIPS #1:
// Choose the left-most body atom with at least one bound argument
// If none exist, prioritise EDB predicates.
int getNextAtomNaiveSIPS(std::vector<AstAtom*> atoms, const std::set<std::string>& boundArgs,
        const std::set<AstRelationIdentifier>& edb, BindingStore& compositeBindings) {
    // find the first available atom with at least one bound argument
    int firstedb = -1;
    int firstidb = -1;
    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        AstRelationIdentifier atomName = currAtom->getName();

        // check if this is the first edb or idb atom met
        if (contains(edb, atomName)) {
            if (firstedb < 0) {
                firstedb = i;
            }
        } else if (firstidb < 0) {
            firstidb = i;
        }

        // if it has at least one bound argument, then adorn this atom next
        if (hasBoundArgument(currAtom, boundArgs, compositeBindings)) {
            return i;
        }
    }

    // all unadorned body atoms only have free arguments
    // choose the first edb remaining if available
    if (firstedb >= 0) {
        return firstedb;
    } else {
        return firstidb;
    }
}

// SIPS #2:
// Choose the body atom with the maximum number of bound arguments
// If equal boundness, prioritise left-most EDB
int getNextAtomMaxBoundSIPS(std::vector<AstAtom*>& atoms, const std::set<std::string>& boundArgs,
        const std::set<AstRelationIdentifier>& edb, BindingStore& compositeBindings) {
    int maxBound = -1;
    int maxIndex = 0;
    bool maxIsEDB = false;  // checks if current max index is an EDB predicate

    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        int numBound = 0;
        for (AstArgument* arg : currAtom->getArguments()) {
            if (isBoundArgument(arg, boundArgs, compositeBindings)) {
                numBound++;
            }
        }

        if (numBound > maxBound) {
            maxBound = numBound;
            maxIndex = i;
            maxIsEDB = contains(edb, currAtom->getName());
        } else if (!maxIsEDB && numBound == maxBound && contains(edb, currAtom->getName())) {
            // prioritise EDB predicates
            maxIsEDB = true;
            maxIndex = i;
        }
    }

    return maxIndex;
}

// Choose the atom with the maximum ratio of bound arguments to total arguments
int getNextAtomMaxRatioSIPS(std::vector<AstAtom*>& atoms, const std::set<std::string>& boundArgs,
        const std::set<AstRelationIdentifier>& edb, BindingStore& compositeBindings) {
    double maxRatio = -1;
    int maxIndex = 0;

    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        int numArguments = currAtom->getArity();
        if (numArguments == 0) {
            return i;  // no arguments!
        }

        int numBound = 0;
        for (AstArgument* arg : currAtom->getArguments()) {
            if (isBoundArgument(arg, boundArgs, compositeBindings)) {
                numBound++;
            }
        }

        double currRatio = numBound * 1.0 / numArguments;

        if (currRatio == 1) {
            return i;  // all bound, not going to get better than this
        }

        if (currRatio > maxRatio) {
            maxRatio = currRatio;
            maxIndex = i;
        }
    }

    return maxIndex;
}

// Choose the SIP Strategy to be used
// Current choice is the max ratio SIPS
int getNextAtomSIPS(std::vector<AstAtom*>& atoms, std::set<std::string> boundArgs,
        std::set<AstRelationIdentifier> edb, BindingStore& compositeBindings) {
    return getNextAtomMaxBoundSIPS(atoms, std::move(boundArgs), std::move(edb), compositeBindings);
}

// Find and stores all composite arguments (namely records and functors) along
// with their variable dependencies
BindingStore bindComposites(const AstProgram* program) {
    struct M : public AstNodeMapper {
        BindingStore& compositeBindings;
        std::set<AstBinaryConstraint*>& constraints;
        mutable int changeCount;

        M(BindingStore& compositeBindings, std::set<AstBinaryConstraint*>& constraints, int changeCount)
                : compositeBindings(compositeBindings), constraints(constraints), changeCount(changeCount) {}

        int getChangeCount() const {
            return changeCount;
        }

        std::unique_ptr<AstNode> operator()(std::unique_ptr<AstNode> node) const override {
            if (auto* functor = dynamic_cast<AstFunctor*>(node.get())) {
                // functor found
                changeCount++;

                // create new variable name (with appropriate suffix)
                std::stringstream newVariableName;
                newVariableName << "+functor" << changeCount;

                // add the binding to the BindingStore
                compositeBindings.addBinding(newVariableName.str(), functor);

                // create new constraint (+functorX = original-functor)
                auto newVariable = std::make_unique<AstVariable>(newVariableName.str());
                constraints.insert(new AstBinaryConstraint(BinaryConstraintOp::EQ,
                        std::unique_ptr<AstArgument>(newVariable->clone()),
                        std::unique_ptr<AstArgument>(functor->clone())));

                // update functor to be the variable created
                return std::move(newVariable);
            } else if (auto* record = dynamic_cast<AstRecordInit*>(node.get())) {
                // record found
                changeCount++;

                // create new variable name (with appropriate suffix)
                std::stringstream newVariableName;
                newVariableName << "+record" << changeCount;

                // add the binding to the BindingStore
                compositeBindings.addBinding(newVariableName.str(), record);

                // create new constraint (+recordX = original-record)
                auto newVariable = std::make_unique<AstVariable>(newVariableName.str());
                constraints.insert(new AstBinaryConstraint(BinaryConstraintOp::EQ,
                        std::unique_ptr<AstArgument>(newVariable->clone()),
                        std::unique_ptr<AstArgument>(record->clone())));

                // update record to be the variable created
                return std::move(newVariable);
            }
            node->apply(*this);
            return node;
        }
    };

    BindingStore compositeBindings;

    int changeCount = 0;  // number of functors/records seen so far

    // apply the change to all clauses in the program
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            std::set<AstBinaryConstraint*> constraints;
            M update(compositeBindings, constraints, changeCount);
            clause->apply(update);

            changeCount = update.getChangeCount();

            for (AstBinaryConstraint* constraint : constraints) {
                clause->addToBody(std::unique_ptr<AstBinaryConstraint>(constraint));
            }
        }
    }

    return compositeBindings;
}

// runs the adornment algorithm on an input program
// Adornment algorithm:

// Let P be the set of all adorned predicates (initially empty)
// Let D' be the set of all adorned clauses (initially empty)
// Let S be the set of all seen predicate adornments

// Get the program
// Get the query
// Adorn the query based on boundness, and add it to P and S
// While P is not empty
// -- Pop the first atom out, call it R^c, where c is the adornment
// -- For every clause Q defining R:
// -- -- Adorn Q using R^c based on the SIPS chosen
// -- -- Add the adorned clause to D'
// -- -- If the body of the adorned clause contains an
//        unseen predicate adornment, add it to S and P

// Output: D' [the set of all adorned clauses]
void Adornment::run(const AstTranslationUnit& translationUnit) {
    // -------------
    // --- Setup ---
    // -------------
    const AstProgram* program = translationUnit.getProgram();
    auto* ioTypes = translationUnit.getAnalysis<IOType>();

    // normalises and tracks bindings of composite arguments (namely records and functors)
    BindingStore compositeBindings = bindComposites(program);

    // set up IDB/EDB and the output queries
    std::vector<AstRelationIdentifier> outputQueries;
    std::vector<std::vector<AdornedClause>> adornedProgram;

    // sort out the relations in the program into EDB/IDB and find computed relations
    for (AstRelation* rel : program->getRelations()) {
        AstRelationIdentifier relName = rel->getName();

        // find computed relations for the topdown part
        if (ioTypes->isOutput(rel)) {
            outputQueries.push_back(rel->getName());
            // add relation to adornment
            adornmentRelations.push_back(rel->getName());
        }

        // check whether edb or idb
        bool is_edb = true;
        for (AstClause* clause : rel->getClauses()) {
            if (!clause->isFact()) {
                is_edb = false;
                break;
            }
        }

        if (is_edb) {
            adornmentEdb.insert(relName);
        } else {
            adornmentIdb.insert(relName);
        }
    }

    // find all negated literals
    visitDepthFirst(*program,
            [&](const AstNegation& negation) { negatedAtoms.insert(negation.getAtom()->getName()); });

    // add the relations needed for negated relations to be computed
    negatedAtoms = addForwardDependencies(program, negatedAtoms);

    // find atoms that should be ignored
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            // ignore atoms that have rules containing aggregators
            if (containsAggregators(clause)) {
                ignoredAtoms.insert(clause->getHead()->getName());
            }

            // ignore all atoms used inside an aggregator within the clause
            ignoredAtoms = addAggregators(clause, ignoredAtoms);
        }
    }

    // find atoms that should be ignored based on magic-transform option
    ignoredAtoms = addIgnoredRelations(program, ignoredAtoms);

    // if a relation is ignored, then all the atoms in its bodies need to be ignored
    ignoredAtoms = addForwardDependencies(program, ignoredAtoms);

    // -----------------
    // --- Adornment ---
    // -----------------
    // begin adornment algorithm
    // adornment is performed for each output query separately
    for (auto outputQuery : outputQueries) {
        std::vector<AdornedPredicate> currentPredicates;
        std::set<AdornedPredicate> seenPredicates;
        std::vector<AdornedClause> adornedClauses;

        // create an adorned predicate of the form outputName_ff..f
        size_t arity = program->getRelation(outputQuery)->getArity();
        std::string frepeat = std::string(arity, 'f');  // #fs = #args
        AdornedPredicate outputPredicate(outputQuery, frepeat);
        currentPredicates.push_back(outputPredicate);
        seenPredicates.insert(outputPredicate);

        // keep going through the remaining predicates that need to be adorned
        while (!currentPredicates.empty()) {
            // pop out the first element
            AdornedPredicate currPredicate = currentPredicates[0];
            currentPredicates.erase(currentPredicates.begin());

            // don't bother adorning ignored predicates
            if (contains(ignoredAtoms, currPredicate.getName())) {
                continue;
            }

            // go through and adorn all IDB clauses defining the relation
            AstRelation* rel = program->getRelation(currPredicate.getName());
            for (AstClause* clause : rel->getClauses()) {
                if (clause->isFact()) {
                    continue;
                }

                size_t numAtoms = clause->getAtoms().size();
                std::vector<std::string> clauseAtomAdornments(numAtoms);
                std::vector<unsigned int> ordering(numAtoms);
                std::set<std::string> boundArgs;

                // mark all bound arguments in the head as bound
                AstAtom* clauseHead = clause->getHead();
                std::string headAdornment = currPredicate.getAdornment();
                std::vector<AstArgument*> headArguments = clauseHead->getArguments();

                for (size_t argnum = 0; argnum < headArguments.size(); argnum++) {
                    if (headAdornment[argnum] == 'b') {
                        std::string name = getString(headArguments[argnum]);
                        boundArgs.insert(name);
                    }
                }

                // mark all bound arguments from the body
                std::vector<AstBinaryConstraint*> constraints = clause->getBinaryConstraints();
                for (AstBinaryConstraint* constraint : constraints) {
                    BinaryConstraintOp op = constraint->getOperator();

                    if (op != BinaryConstraintOp::EQ) {
                        continue;
                    }

                    AstArgument* lhs = constraint->getLHS();
                    AstArgument* rhs = constraint->getRHS();
                    if (isBindingConstraint(lhs, rhs, boundArgs)) {
                        boundArgs.insert(getString(lhs));
                    }
                    if (isBindingConstraint(rhs, lhs, boundArgs)) {
                        boundArgs.insert(getString(rhs));
                    }
                }

                std::vector<AstAtom*> atoms = clause->getAtoms();
                int atomsAdorned = 0;
                int atomsTotal = atoms.size();

                while (atomsAdorned < atomsTotal) {
                    // get the next body atom to adorn based on our SIPS
                    int currIndex = getNextAtomSIPS(atoms, boundArgs, adornmentEdb, compositeBindings);
                    AstAtom* currAtom = atoms[currIndex];
                    AstRelationIdentifier atomName = currAtom->getName();

                    // compute the adornment pattern of this atom, and
                    // add all its arguments to the list of bound args
                    std::pair<std::string, std::set<std::string>> result =
                            bindArguments(currAtom, boundArgs, compositeBindings);
                    std::string atomAdornment = result.first;
                    boundArgs = result.second;

                    // check if we've already dealt with this adornment before
                    if (!contains(seenPredicates, atomName, atomAdornment)) {
                        // not seen before, so push it onto the computation list
                        // and mark it as seen
                        currentPredicates.push_back(AdornedPredicate(atomName, atomAdornment));
                        seenPredicates.insert(AdornedPredicate(atomName, atomAdornment));
                    }

                    clauseAtomAdornments[currIndex] = atomAdornment;  // store the adornment
                    ordering[currIndex] = atomsAdorned;               // mark what atom number this is
                    atoms[currIndex] = nullptr;                       // mark as done

                    atomsAdorned++;
                }

                // adornment of this clause is complete - add it to the list of
                // adorned clauses
                adornedClauses.push_back(
                        AdornedClause(clause, headAdornment, clauseAtomAdornments, ordering));
            }
        }

        // add the list of adorned clauses matching the current output relation
        adornmentClauses.push_back(adornedClauses);
    }

    this->bindings = std::move(compositeBindings);
}

// output the adornment analysis computed
// format: 'Output <outputNumber>: <outputName>' followed by a list of the
// related clause adornments, each on a new line
void Adornment::print(std::ostream& os) const {
    for (size_t i = 0; i < adornmentClauses.size(); i++) {
        std::vector<AdornedClause> clauses = adornmentClauses[i];
        os << "Output " << i + 1 << ": " << adornmentRelations[i] << std::endl;
        for (AdornedClause clause : clauses) {
            os << clause << std::endl;
        }
        os << std::endl;
    }
}

/* =======================  *
 * Magic Set Transformation *
 * =======================  */

// transforms the program so that a relation is either purely made up of
// facts or has no facts at all
void separateDBs(AstProgram* program) {
    for (AstRelation* relation : program->getRelations()) {
        AstRelationIdentifier relName = relation->getName();

        // determine whether the relation fits into the EDB, IDB, or both
        bool is_edb = false;
        bool is_idb = false;

        for (AstClause* clause : relation->getClauses()) {
            if (clause->isFact()) {
                is_edb = true;
            } else {
                is_idb = true;
            }
            if (is_edb && is_idb) {
                break;
            }
        }

        if (is_edb && is_idb) {
            // relation is part of EDB and IDB

            // move all the relation's facts to a new relation with a unique name
            std::string newEdbName = getNextEdbName(program);
            AstRelation* newEdbRel = createNewRelation(relation, newEdbName);
            program->appendRelation(std::unique_ptr<AstRelation>(newEdbRel));

            // find all facts for the relation
            for (AstClause* clause : relation->getClauses()) {
                if (clause->isFact()) {
                    // clause is fact - add it to the new EDB relation
                    AstClause* newEdbClause = clause->clone();
                    newEdbClause->getHead()->setName(newEdbName);
                    program->appendClause(std::unique_ptr<AstClause>(newEdbClause));
                }
            }

            // add a rule to the old relation that relates it to the new relation
            auto* newIdbClause = new AstClause();
            newIdbClause->setSrcLoc(nextSrcLoc(relation->getSrcLoc()));

            // oldname(arg1...argn) :- newname(arg1...argn)
            auto* headAtom = new AstAtom(relName);
            auto* bodyAtom = new AstAtom(newEdbName);

            size_t numargs = relation->getArity();
            for (size_t j = 0; j < numargs; j++) {
                std::stringstream argName;
                argName.str("");
                argName << "arg" << j;
                headAtom->addArgument(std::make_unique<AstVariable>(argName.str()));
                bodyAtom->addArgument(std::make_unique<AstVariable>(argName.str()));
            }

            newIdbClause->setHead(std::unique_ptr<AstAtom>(headAtom));
            newIdbClause->addToBody(std::unique_ptr<AstAtom>(bodyAtom));

            program->appendClause(std::unique_ptr<AstClause>(newIdbClause));
        }
    }
}

// returns the adornment of an (adorned) magic identifier
std::string extractAdornment(const AstRelationIdentifier& magicRelationName) {
    std::string baseRelationName = magicRelationName.getNames()[0];
    int endpt = getEndpoint(baseRelationName);
    std::string adornment = baseRelationName.substr(endpt + 1, baseRelationName.size() - (endpt + 1));
    return adornment;
}

// returns the constant represented by a variable of the form "+abdulX_variablevalue_X"
AstArgument* extractConstant(SymbolTable& symbolTable, const std::string& normalisedConstant) {
    // strip off the prefix up to (and including) the first underscore
    size_t argStart = normalisedConstant.find('_');
    std::string arg = normalisedConstant.substr(argStart + 1, normalisedConstant.size());

    // -- check if string or num constant --
    char indicatorChar = arg[arg.size() - 1];  // 'n' or 's'
    std::string stringRep = arg.substr(0, arg.size() - 2);

    if (indicatorChar == 's') {
        // string argument
        return new AstStringConstant(symbolTable, stringRep);
    } else if (indicatorChar == 'n') {
        // numeric argument
        return new AstNumberConstant(stoi(stringRep));
    } else {
        // invalid format
        return nullptr;
    }
}

// creates a new magic relation based on a given relation and magic base name
AstRelation* createMagicRelation(AstRelation* original, const AstRelationIdentifier& magicPredName) {
    // get the adornment of this argument
    std::string adornment = extractAdornment(magicPredName);

    // create the relation
    auto* newMagicRelation = new AstRelation();
    newMagicRelation->setName(magicPredName);

    // copy over (bound) attributes from the original relation
    std::vector<AstAttribute*> attrs = original->getAttributes();
    for (size_t currentArg = 0; currentArg < original->getArity(); currentArg++) {
        if (adornment[currentArg] == 'b') {
            newMagicRelation->addAttribute(std::unique_ptr<AstAttribute>(attrs[currentArg]->clone()));
        }
    }

    return newMagicRelation;
}

// transforms the program so that all underscores previously transformed
// to a "+underscoreX" are changed back to underscores
void replaceUnderscores(AstProgram* program) {
    struct M : public AstNodeMapper {
        std::unique_ptr<AstNode> operator()(std::unique_ptr<AstNode> node) const override {
            if (auto* var = dynamic_cast<AstVariable*>(node.get())) {
                if (hasPrefix(var->getName(), "+underscore")) {
                    return std::make_unique<AstUnnamedVariable>();
                }
            }
            node->apply(*this);
            return node;
        }
    };

    M update;
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            clause->apply(update);
        }
    }
}

// Magic Set Transformation
// STEPS:
// For all output relations G:
// -- Get the adornment S for this clause
// -- Add to S the set of magic rules for all clauses in S:
// -- -- For each clause C = A^a :- A1^a1, A2^a2, ..., An^an
// -- -- -- For each IDB literal A_i in the body of C
// -- -- -- -- Add mag(Ai^ai) :- mag(A^a), A1^a1, ..., Ai-1^ai-1 to the program
// -- For all clauses H :- T in S:
// -- -- Replace the clause with H :- mag(H), T.
// -- Add the fact m_G_f...f to S
// Remove all old idb rules
bool MagicSetTransformer::transform(AstTranslationUnit& translationUnit) {
    AstProgram* program = translationUnit.getProgram();
    auto* ioTypes = translationUnit.getAnalysis<IOType>();

    separateDBs(program);  // make EDB int IDB = empty

    auto* adornment = translationUnit.getAnalysis<Adornment>();  // perform adornment
    const BindingStore& compositeBindings = adornment->getBindings();

    // edb/idb handling
    std::vector<std::vector<AdornedClause>> allAdornedClauses = adornment->getAdornedClauses();
    std::set<AstRelationIdentifier> negatedAtoms = adornment->getNegatedAtoms();
    std::set<AstRelationIdentifier> ignoredAtoms = adornment->getIgnoredAtoms();
    std::set<AstRelationIdentifier> oldIdb = adornment->getIDB();
    std::set<AstRelationIdentifier> newIdb;

    // additions
    std::vector<AstRelationIdentifier> newQueryNames;
    std::vector<AstClause*> newClauses;

    // output handling
    std::vector<AstRelationIdentifier> outputQueries = adornment->getRelations();
    std::set<AstRelationIdentifier> addAsOutput;
    std::set<AstRelationIdentifier> addAsPrintSize;
    std::map<AstRelationIdentifier, std::vector<std::unique_ptr<AstStore>>> outputDirectives;
    std::map<AstRelationIdentifier, std::vector<std::unique_ptr<AstPrintSize>>> printSizeDirectives;

    // ignore negated atoms
    for (AstRelationIdentifier relation : negatedAtoms) {
        ignoredAtoms.insert(relation);
    }

    // perform magic set algorithm for each output
    for (size_t querynum = 0; querynum < outputQueries.size(); querynum++) {
        AstRelationIdentifier outputQuery = outputQueries[querynum];
        std::vector<AdornedClause> adornedClauses = allAdornedClauses[querynum];
        AstRelation* originalOutputRelation = program->getRelation(outputQuery);

        // add a relation for the output query
        // mN_outputname_ff...f()
        auto* magicOutputRelation = new AstRelation();
        std::string frepeat = std::string(originalOutputRelation->getArity(), 'f');
        AstRelationIdentifier magicOutputName =
                createMagicIdentifier(createAdornedIdentifier(outputQuery, frepeat), querynum);
        magicOutputRelation->setName(magicOutputName);
        newQueryNames.push_back(magicOutputName);

        // add the new relation to the program
        program->appendRelation(std::unique_ptr<AstRelation>(magicOutputRelation));

        // add an empty fact to the program
        // i.e. mN_outputname_ff...f().
        auto* outputFact = new AstClause();
        outputFact->setSrcLoc(nextSrcLoc(originalOutputRelation->getSrcLoc()));
        outputFact->setHead(std::make_unique<AstAtom>(magicOutputName));
        program->appendClause(std::unique_ptr<AstClause>(outputFact));

        // perform the magic transformation based on the adornment for this output query
        for (AdornedClause adornedClause : adornedClauses) {
            AstClause* clause = adornedClause.getClause();
            AstRelationIdentifier originalName = clause->getHead()->getName();

            // dont perform the magic transformation on ignored relations
            if (contains(ignoredAtoms, originalName)) {
                continue;
            }

            // find the adorned version of this relation
            std::string headAdornment = adornedClause.getHeadAdornment();
            AstRelationIdentifier newRelName = createAdornedIdentifier(originalName, headAdornment);
            AstRelation* adornedRelation = program->getRelation(newRelName);

            // check if adorned relation already created previously
            if (adornedRelation == nullptr) {
                // adorned relation not created yet, so
                // create the relation with the new adornment
                AstRelation* originalRelation = program->getRelation(originalName);
                AstRelation* newRelation = createNewRelation(originalRelation, newRelName);

                // copy over input directives to new adorned relation
                // also - update input directives to correctly use default fact file names
                if (ioTypes->isInput(originalRelation)) {
                    IODirectives inputDirectives;  // to more easily work with the directive
                    auto* newDirective = new AstLoad();
                    inputDirectives.setRelationName(newRelName.getNames()[0]);
                    newDirective->addName(newRelName);
                    visitDepthFirst(*program, [&](const AstLoad& current) {
                        if (current.getName() == originalName) {
                            for (const auto& currentPair : current.getIODirectiveMap()) {
                                newDirective->addKVP(currentPair.first, currentPair.second);
                                inputDirectives.set(currentPair.first, currentPair.second);
                            }
                        }
                    });
                    if (!inputDirectives.has("IO")) {
                        inputDirectives.setIOType("file");
                        newDirective->addKVP("IO", "file");
                    }
                    if (inputDirectives.getIOType() == "file" && !inputDirectives.has("filename")) {
                        newDirective->addKVP("filename", originalName.getNames()[0] + ".facts");
                    }

                    newRelation->addLoad(std::unique_ptr<AstLoad>(newDirective));
                }

                // add the created adorned relation to the program
                program->appendRelation(std::unique_ptr<AstRelation>(newRelation));
                adornedRelation = newRelation;
            }

            // create the adorned version of this clause
            AstClause* newClause = clause->clone();
            newClause->getHead()->setName(newRelName);
            // reorder atoms based on SIPS ordering
            newClause->reorderAtoms(reorderOrdering(adornedClause.getOrdering()));

            // get corresponding adornments for each body atom
            std::vector<std::string> bodyAdornment =
                    reorderAdornment(adornedClause.getBodyAdornment(), adornedClause.getOrdering());

            // set the name of each IDB pred in the clause to be the adorned version
            int atomsSeen = 0;
            for (AstLiteral* lit : newClause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit)) {
                    auto* bodyAtom = dynamic_cast<AstAtom*>(lit);
                    AstRelationIdentifier atomName = bodyAtom->getName();
                    // note that all atoms in the original clause were adorned,
                    // but only the IDB atom adornments should be added here
                    if (contains(oldIdb, atomName)) {
                        if (!contains(ignoredAtoms, atomName)) {
                            // ignored atoms should not be changed
                            AstRelationIdentifier newAtomName =
                                    createAdornedIdentifier(atomName, bodyAdornment[atomsSeen]);
                            bodyAtom->setName(newAtomName);
                            newIdb.insert(newAtomName);
                        } else {
                            newIdb.insert(atomName);
                        }
                    }
                    atomsSeen++;
                }
            }

            // Add the set of magic rules for this clause C = A^a :- A1^a1, A2^a2, ..., An^an
            // -- For each clause C = A^a :- A1^a1, A2^a2, ..., An^an
            // -- -- For each IDB literal A_i in the body of C
            // -- -- -- Add mag(Ai^ai) :- mag(A^a), A1^a1, ..., Ai-1^ai-1 to the program
            std::vector<AstLiteral*> body = newClause->getBodyLiterals();
            for (size_t i = 0; i < body.size(); i++) {
                AstLiteral* currentLiteral = body[i];

                // only care about atoms in the body
                if (dynamic_cast<AstAtom*>(currentLiteral)) {
                    auto* atom = dynamic_cast<AstAtom*>(currentLiteral);
                    AstRelationIdentifier atomName = atom->getName();

                    // only IDB atoms that are not being ignored matter
                    if (contains(newIdb, atomName) && !contains(ignoredAtoms, atomName)) {
                        std::string currAdornment = bodyAdornment[i];

                        // generate the name of the magic version of this adorned literal
                        AstRelationIdentifier newAtomName = createMagicIdentifier(atomName, querynum);

                        // if the magic version does not exist, create it
                        if (program->getRelation(newAtomName) == nullptr) {
                            auto* magicRelation = new AstRelation();
                            magicRelation->setName(newAtomName);

                            // find out the original name of the relation (pre-adornment)
                            std::string baseAtomName = atomName.getNames()[0];
                            int endpt = getEndpoint(baseAtomName);
                            AstRelationIdentifier originalRelationName = createSubIdentifier(
                                    atomName, 0, endpt - 1);  // get rid of the extra + at the end
                            AstRelation* originalRelation = program->getRelation(originalRelationName);

                            // copy over the (bound) attributes from the original relation
                            int argcount = 0;
                            for (AstAttribute* attr : originalRelation->getAttributes()) {
                                if (currAdornment[argcount] == 'b') {
                                    magicRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
                                }
                                argcount++;
                            }

                            // add in relevant qualifiers from original relation
                            updateQualifier(originalRelation, magicRelation);

                            // add the new magic relation to the program
                            program->appendRelation(std::unique_ptr<AstRelation>(magicRelation));
                        }

                        // start setting up the magic rule
                        auto* magicClause = new AstClause();
                        magicClause->setSrcLoc(nextSrcLoc(atom->getSrcLoc()));

                        // create the head of the magic rule
                        auto* magicHead = new AstAtom(newAtomName);

                        // copy over (bound) arguments from the original atom
                        int argCount = 0;
                        for (AstArgument* arg : atom->getArguments()) {
                            if (currAdornment[argCount] == 'b') {
                                magicHead->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        // head complete!
                        magicClause->setHead(std::unique_ptr<AstAtom>(magicHead));

                        // -- create the body --
                        // create the first body argument (mag(origClauseHead^adornment))
                        AstRelationIdentifier magPredName =
                                createMagicIdentifier(newClause->getHead()->getName(), querynum);
                        auto* addedMagicPred = new AstAtom(magPredName);

                        // create the relation if it does not exist
                        if (program->getRelation(magPredName) == nullptr) {
                            AstRelation* originalRelation =
                                    program->getRelation(newClause->getHead()->getName());
                            AstRelation* newMagicRelation =
                                    createMagicRelation(originalRelation, magPredName);

                            // add the new relation to the prgoram
                            program->appendRelation(std::unique_ptr<AstRelation>(newMagicRelation));
                        }

                        // add (bound) arguments to the magic predicate from the clause head
                        argCount = 0;
                        for (AstArgument* arg : newClause->getHead()->getArguments()) {
                            if (headAdornment[argCount] == 'b') {
                                addedMagicPred->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        // first argument complete!
                        magicClause->addToBody(std::unique_ptr<AstAtom>(addedMagicPred));

                        // add the rest of the necessary arguments
                        for (size_t j = 0; j < i; j++) {
                            magicClause->addToBody(std::unique_ptr<AstLiteral>(body[j]->clone()));
                        }

                        // restore memorised bindings for all composite arguments
                        std::vector<const AstArgument*> compositeArguments;
                        visitDepthFirst(*magicClause, [&](const AstArgument& argument) {
                            std::string argName = getString(&argument);
                            if (hasPrefix(argName, "+functor") || hasPrefix(argName, "+record")) {
                                compositeArguments.push_back(&argument);
                            }
                        });

                        for (const AstArgument* compositeArgument : compositeArguments) {
                            std::string argName = getString(compositeArgument);

                            // if the composite argument was bound only because all
                            // of its constituent variables were bound, then bind
                            // the composite variable to the original argument
                            if (compositeBindings.isVariableBoundComposite(argName)) {
                                AstArgument* originalArgument =
                                        compositeBindings.cloneOriginalArgument(argName);
                                magicClause->addToBody(
                                        std::make_unique<AstBinaryConstraint>(BinaryConstraintOp::EQ,
                                                std::unique_ptr<AstArgument>(compositeArgument->clone()),
                                                std::unique_ptr<AstArgument>(originalArgument)));
                            }
                        }

                        // restore bindings for normalised constants
                        std::vector<const AstVariable*> clauseVariables;
                        visitDepthFirst(*magicClause,
                                [&](const AstVariable& variable) { clauseVariables.push_back(&variable); });

                        for (const AstVariable* var : clauseVariables) {
                            std::string varName = getString(var);

                            // all normalised constants begin with "+abdul" (see AstTransforms.cpp)
                            // +abdulX_variablevalue_Y
                            if (hasPrefix(varName, "+abdul")) {
                                AstArgument* embeddedConstant =
                                        extractConstant(translationUnit.getSymbolTable(), varName);

                                // add the constraint to the body of the clause
                                magicClause->addToBody(std::make_unique<AstBinaryConstraint>(
                                        BinaryConstraintOp::EQ, std::unique_ptr<AstArgument>(var->clone()),
                                        std::unique_ptr<AstArgument>(embeddedConstant)));
                            }
                        }

                        // magic rule done! add it to the program
                        program->appendClause(std::unique_ptr<AstClause>(magicClause));
                    }
                }
            }

            // -- replace with H :- mag(H), T --

            size_t originalNumAtoms = newClause->getAtoms().size();

            // create the first argument of this new clause
            const AstAtom* newClauseHead = newClause->getHead()->getAtom();
            AstRelationIdentifier newMag = createMagicIdentifier(newClauseHead->getName(), querynum);
            auto* newMagAtom = new AstAtom(newMag);

            // copy over the bound arguments from the head
            std::vector<AstArgument*> args = newClauseHead->getArguments();
            for (size_t k = 0; k < args.size(); k++) {
                if (headAdornment[k] == 'b') {
                    newMagAtom->addArgument(std::unique_ptr<AstArgument>(args[k]->clone()));
                }
            }

            // add it to the end of the clause
            newClause->addToBody(std::unique_ptr<AstAtom>(newMagAtom));

            // move the new magic argument to the front of the clause,
            // pushing all the rest up one position
            std::vector<unsigned int> newClauseOrder(originalNumAtoms + 1);
            for (size_t k = 0; k < originalNumAtoms; k++) {
                newClauseOrder[k] = k + 1;
            }
            newClauseOrder[originalNumAtoms] = 0;
            newClause->reorderAtoms(reorderOrdering(newClauseOrder));

            // add the clause to the program and the set of new clauses
            newClause->setSrcLoc(nextSrcLoc(newClause->getSrcLoc()));
            newClauses.push_back(newClause);
            adornedRelation->addClause(std::unique_ptr<AstClause>(newClause));
        }
    }

    // remove all transformed old IDB relations, making sure to preserve input/output directives
    for (AstRelationIdentifier relationName : oldIdb) {
        AstRelation* relation = program->getRelation(relationName);

        // before deleting, store the directives of computed relations
        // for restoration later on
        if (ioTypes->isOutput(relation)) {
            addAsOutput.insert(relationName);
            std::vector<std::unique_ptr<AstStore>> clonedDirectives;
            visitDepthFirst(*program, [&](const AstStore current) {
                if (current.getName() == relationName) {
                    clonedDirectives.emplace_back(current.clone());
                }
            });
            outputDirectives[relationName] = std::move(clonedDirectives);
        }

        // do not delete negated atoms, ignored atoms, or atoms added by aggregate relations
        if (!(contains(ignoredAtoms, relationName) || contains(negatedAtoms, relationName) ||
                    isAggRel(relationName))) {
            program->removeRelation(relationName);
        }
    }

    // add the new output relations
    // in particular, need to rename the adorned output back to the original name
    for (size_t i = 0; i < outputQueries.size(); i++) {
        AstRelationIdentifier oldName = outputQueries[i];
        AstRelationIdentifier newName = newQueryNames[i];

        // get the original adorned relation
        std::string newBaseName = newName.getNames()[0];
        size_t prefixpoint = newBaseName.find("_");
        AstRelationIdentifier newRelationName =
                createSubIdentifier(newName, prefixpoint + 1, newBaseName.size() - (prefixpoint + 1));

        AstRelation* adornedRelation = program->getRelation(newRelationName);

        if (adornedRelation == nullptr) {
            continue;
        }

        AstRelation* outputRelation = program->getRelation(oldName);

        // if the corresponding output relation does not exist yet, create it
        if (outputRelation == nullptr) {
            outputRelation = new AstRelation();
            outputRelation->setSrcLoc(nextSrcLoc(adornedRelation->getSrcLoc()));

            // copy over the attributes from the existing adorned version
            for (AstAttribute* attr : adornedRelation->getAttributes()) {
                outputRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
            }

            // rename it back to its original name
            outputRelation->setName(oldName);
            /*
             * Should this actually happen? If so, where do the attributes come from?
                        // set as output relation
                        if (addAsOutput.find(oldName) != addAsOutput.end()) {
                            outputRelation->addStore(std::make_unique<AstStore>());
                        } else {
                            outputRelation->setPrintSize(std::make_unique<AstPrintSize>());
                        }
            */
            // add the new output to the program
            program->appendRelation(std::unique_ptr<AstRelation>(outputRelation));
        }

        // rules need to be the same
        // easy fix:
        //    oldname(arg1...argn) :- newname(arg1...argn)
        auto* headatom = new AstAtom(oldName);
        auto* bodyatom = new AstAtom(newRelationName);

        for (size_t j = 0; j < adornedRelation->getArity(); j++) {
            std::stringstream argName;
            argName.str("");
            argName << "arg" << j;
            headatom->addArgument(std::make_unique<AstVariable>(argName.str()));
            bodyatom->addArgument(std::make_unique<AstVariable>(argName.str()));
        }

        // add the clause to the program
        auto* referringClause = new AstClause();
        referringClause->setSrcLoc(nextSrcLoc(outputRelation->getSrcLoc()));
        referringClause->setHead(std::unique_ptr<AstAtom>(headatom));
        referringClause->addToBody(std::unique_ptr<AstAtom>(bodyatom));

        program->appendClause(std::unique_ptr<AstClause>(referringClause));
    }

    // add in all the output directives to their corresponding relations
    for (auto& iopair : outputDirectives) {
        for (auto& iodir : iopair.second) {
            program->getRelation(iopair.first)->addStore(std::move(iodir));
        }
    }

    // replace all "+underscoreX" variables with actual underscores
    replaceUnderscores(program);

    // done!
    return true;
}
}  // end of namespace souffle
